<!DOCTYPE html>
<html>
  <head>
    <title>Functions 1</title>
    <meta charset="utf-8">
    <style>

      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import "style.css";
    
    </style>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </head>
  <body>
    <textarea id="source">

name: inverse
layout: true

---
class: center, middle

# Functions on Variables

---

## Agenda

1. What is a function?
2. Inputs / outputs / side effects
3. Runtime analysis
4. Coding

---
class: center

## What is a function?

---

## What is a function? 

- They combine multiple statements into a single line of code by "encapsulating" a task
- They are "black boxes", we don't care how it works, only that it works
- When they're "called" the program "enters" the functions' scope

```
ReturnType function_name( parameters ) {
    // This is inside of the functions scope.
    statement1;
    statement2;
    statement3;
    return something or nothing;
}
```

---

## Why do we write functions?

- To reuse code instead of re-writing it
- To break programs into small, more manageable, sub-steps
- To keep our namespace clean, variables declared inside of functions don't survive function termination unless they're declared on the heap
- To test and ensure functionality in small components of code that have easily testable inputs / outputs / side effects

---

## How to write a function

1. Define a clear purpose (notice a pattern of repeated code, or a small section that is completely independent from the rest of the program)
2. Define the inputs to the program (what parameters the function will need)
3. Define the steps the function should take, and the variables it will need, to complete it's goal (the algorithm)

---

## Inputs / Outputs / Side effects

- **Inputs** are what a function receives, they should modify behavior so that the function can be flexible (addition can take any two numbers, and it's output depends on them)
- **Outputs** are what a function returns
- **Side Effects** are changes to the outside world that a function causes

In general functions should either have outputs or side effects, but not both.
For example, `sort()` and `sorted()` in [Python](https://docs.python.org/3/howto/sorting.html).

---

## Which of the following programs have outputs? Side effects? Both?

```c++
int add(int *a, int *b) {
  return *a + *b;
}
```

```c++
int add(int *a, int *b) {
  *a += *b;
}
```

```c++
int add(int *a, int *b) {
  *a += *b;
  return *a;
}
```

---

## Can you think of some other useful functions?

---

## Function Scope

- All functions have a scope, within that scope they can use anything they are *passed* as parameters, and anything they declare themselves
- Functions cannot access variables they do not create or receive
- This allows you to reuse variable names in different scopes!

---

## Runtime analysis

- As a developer, when you call a function, you must consider how long that function will take to complete, or it's *runtime*.

Can you think of some ways we could measure a functions' runtime? 

---

## Empirical Analysis

- The process of actually running and timing code on your machine
- What are some pros and cons to this approach?

--

### Pros 

- Provides a way to compare similar algorithms

### Cons

- Machine and language dependent, unreliable results
- Does not provide reliable metrics as input varies
- Have to implement the algorithm

--

**We can do better**

---

## Asymptotic Analysis

How long does an algorithm take as a function of its input?

By counting various operations performed, we can determine what algorithms will perform better given arbitrarily large inputs.

We have three primary tools to describe an algorithms asymptotic performance:
- Upper Bound: "Big-Oh" $O()$ The worst case performance
- Lower Bound: "Big-Omega" $\Omega()$ The best case performance
- If they are both the same: "Big-Theta" $\Theta()$ This is a *tight bound*

---

## What is the $O()$ notation for the following?

```c++
int add(int a, int b) {
  return a + b;
}
```

```c++
int fact(int n) {
  int product = 1;
  for (int i = 1; i < n; ++i)
    product *= i;
  return product;
}
```

```c++
void func(int n) {
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
      std::cout << i + j << std::endl;
    }
  }
}
```

```c++
void funky(int n) {
  while (n > 0) --n;
  while (n < 0) ++n;
}
```

---
class: middle, center

![Growth Rates](growth_rate1.png)

We can see that $20n < n!$ as $n \rightarrow \inf$, but let's zoom in on smaller values of $n$

---
class: middle, center

![Growth Rates](growth_rate2.png)

It is not always clear cut that an asymptotically better algorithm is the better fit!

---

## Conclusions

- When discussing algorithm performance, it is best to use non-hardware dependant characterizations
- Asymptotic growth is the best method to compare classes of algorithms
- Even with that analysis, it is worth it to optimize for your problem! If you will always deal with very small values for your input, the constants become much more important than the asymptotic growth.

We will see later in this course algorithms that combine these above principles to optimize their own performance!

---

## Your turn to implement and analyze some functions!

1. Make sure you have updated your repository.
2. Navigate to the `source` directory.
3. You should see a `functions.hpp` header file.
4. It is your job to create `functions.cpp`, implement and analyze the functions, and pass all of the unit tests.

Be sure to write clean, concise code, remember there are 25 points up for grabs!

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>