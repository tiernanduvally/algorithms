<!DOCTYPE html>
<html>

<head>
  <title>Recursion</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    @import "style.css";
  </style>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
</head>

<body>
  <textarea id="source">

name: inverse
layout: true

---
class: center, middle

# Recursion and Recurrences

---

## Agenda

1. Recurrence Relations
2. Recursion

---
class: center, middle

## Recurrence Relations

---

### Motivation

Runtimes for recursive functions are most easily expressed by recurrence relations, for example, the recursive definition for factorial:

$$n! = (n - 1)! \cdot n, \forall n > 1; 1! = 0! = 1$$

Has the recurrence:

$$T(n) = T(n - 1) + 1, \forall n > 1; T(0) = T(1) = 0$$

--

The question is, how can we solve these recurrences? Fortunately, there are many different methods.

---

### Unrolling a recurrence

The process of expanding and simplifying until a pattern can be identified.

$$
\begin{align} 
T(n) &= T(n - 1) + 1; T(0) = T(1) = 1 \\\\
T(n - 1) &= T(n - 2) + 1 \\\\
T(n) &= (T(n -1) + 1) + 1 \\\\
T(n - 2) &= T(n - 3) + 1 \\\\
T(n) &= ((T(n - 3) + 1) + 1) + 1 \\\\
&= T(n - 3) + 3 \\\\
&= T(n - k) + k
\end{align}
$$

At this point we can solve for $T(n - k) = T(0)$:

$$
\begin{align}
n - k &= 0 \\\\
n &= k
\end{align}
$$

Finally, we can substitute that solution into our recurrence:

$$
\begin{align}
T(n) &= T(n - n) + n \\\\
T(n) &= 1 + n \\\\
T(n) &= n = O(n)
\end{align}
$$

---

### Unrolling a recurrence (cont)

$$
\begin{align}
T(n) &= T(n - 1) + n; T(1) = 1 \\\\
T(n - 1) &= T(n - 2) + n - 1 \\\\
T(n) &= (T(n - 2) + n - 1) + n \\\\
T(n - 2) &= T(n - 3) + n - 2 \\\\
T(n) &= ((T(n - 3) + n - 2) + n - 1) + n \\\\
&= T(n - 3) + 3n - 3 \\\\
&= T(n - k) + kn - k \\\\
n - k &= 1 \\\\
k &= n - 1 \\\\
T(n) &= T(n - (n - 1)) + (n - 1)n - (n - 1) \\\\
T(n) &= T(1) + n^2 - n - n + 1 \\\\
T(n) &= 1 + n^2 - 2n +1 \\\\
&= O(n^2)
\end{align}
$$

--

But this is not *quite* right.

---

### Unrolling with summations

$$
\begin{align}
T(n) &= n + T(n - 1) \\\\
&= n + (n - 1 + T(n - 2)) \\\\
&= n + (n - 1 + (n - 2 + T(n - 3))) \\\\
&= n + (n - 1 + (n - 2 + (n - 3 + T(n - 4)))) \\\\
&= n + (n - 1 + (n - 2 + (n - 3 + (n - 4 + (... + 1)))) \\\\
&= \sum_{i = 1}^n i \\\\
&= \frac{n(n + 1)}{2}
\end{align}
$$

---

### Unrolling with summations (cont)

$$
\begin{align}
T(n) &= 2T(n - 1) + 3; T(1) = 1 \\\\
&= 2(2T(n - 2) + 3) + 3 \\\\
&= 2(2(2T(n - 3) + 3) + 3) + 3 \\\\
&= 2(2^2 T(n - 3) + 2 \cdot 3 + 3) + 3 \\\\
&= 2^3 T(n - 3) + 2^2 \cdot 3 + 2 \cdot 3 + 3 \\\\
&= 2^k T(n - k) + \sum_{i = 0}^{k - 1} 2^i \cdot 3
\end{align}
$$

Solving for our base case yields $k = n - 1$

$$
\begin{align}
T(n) &= 2^{n - 1} + \sum_{i = 0}^{n - 2} 2^i \cdot 3 \\\\
T(n) &= 2^{n - 1} + 3 (2^{n - 1} - 1) = O(2^n)
\end{align}
$$

---
class: center, middle

### Summation Identities

MathJax would not let me typeset them for you, so here's a link:

[Wikipedia to the rescue](https://en.wikipedia.org/wiki/Summation#Identities)

---

### Additional Methods

In this class we will primarily use unrolling, however there are **much** more powerful methods to solve recurrences.

If you wish to learn those methods you will not be penalized, and you may save a ton of time during exams!

If you choose not to, you will be **fine**, exams are written with the unrolling methods in mind.

Either way, there will be at least one question on the exam where you will be required to use unrolling.

---
class: center, middle

## Recursion

---

### What is recursion

The process of breaking down larger problems into smaller, more easily solvable ones, then recombining the solutions.

Example: MergeSort

As we saw yesterday, an array is sorted if it contains $n \leq 2$ elements. 

MergeSort exploits this by breaking an array into singletons, then merging those singletons back together into a sorted array.

--

MergeSort breaks a hard problem down into many subproblems that are solved in $O(1)$ time, then works to recombine them.

---

### Some basic requirements

- Recursive functions must call themselves with reduced parameters
- There must be a **base case** when the problem can be solved trivially

The hard part is figuring out how to recursively work down to the base case!

--

```c++
int multiply(int a, int b) {
  return (a == 1) ? b : multiple(a - 1, b) + b;
}
```

What's the base case? How are we recursively getting down to it?

---

### Base Case Troubles

The most common issue when dealing with recursion is the base case.

As a rule of thumb, select the smallest base case possible.

Example: Array Sum

```
Algorithm sum(array, n):
  if n == 2:
    return array[0] + array[1]
  else:
    return array[0] + sum(array[1:], n - 1)

Algorithm sum(array, n):
  if n == 1:
    return array[0] + array[1]
  else:
    return array[0] + sum(array[1:], n - 1)

Algorithm sum(array, n):
  if n == 0:
    return array[0] + array[1]
  else:
    return array[0] + sum(array[1:], n - 1)
```

---
class: center, middle

## Your Goal Today

Re-implement all the functions from the past two days using recursion.

Note that some of the functions may require additional helpers

---

## Instructions

Open VS Code, you should be on a branch other than master.

Terminal commands to prepare your workspace for today's activities:

```bash
git add *
git commit -m "Your message here"
git checkout master
git fetch upstream
git merge upstream/master
git checkout -b lab/recursion
```

Compile and run with `g++ source/functions.cpp && ./a.out`

    </textarea>
  <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>

  <script>
    var slideshow = remark.create();
  </script>
</body>

</html>